<html>
  <head>
    <script src="https://d3js.org/d3.v7.min.js"></script>
  </head>

  <body>
    <div id="plot1"></div>

    <div id="plot2"></div>
    <script>
      // where the formatted data will be stored
      let visualization_data = {};

      //  load movie data with aync request
      d3.csv("movies.csv").then(function (moviesData) {
        // the "ratings.csv" data was generated via OMDB API requests
        // (see "fill_ratings_csv.py" for reference)
        //  load rating data for each movie with aync request
        d3.csv("ratings.csv").then(function (ratingsData) {
          // first populate movies data
          moviesData.forEach(function (data) {
            movie_name = data["Movie Name"];
            movie_data = [];
            // if in data dict, just update the relationship_ages
            if (movie_name in visualization_data) {
              movie_data = visualization_data[movie_name];
            }
            // if not already in data dict, create the initial dictionary struct
            else {
              movie_data = {
                relationship_ages: [],
                movie_year: Number(data["Release Year"]),
              };
            }
            // add the relationship
            movie_data["relationship_ages"].push([
              Number(data["Actor 1 Age"]),
              Number(data["Actor 2 Age"]),
            ]);
            visualization_data[movie_name] = movie_data;
          });

          // next populate ratings data
          ratingsData.forEach(function (data) {
            movie_name = data["Movie Title"];
            movie_rating = data["Imdb Rating"];
            movie_data = visualization_data[movie_name];

            // remove movie data without any ratings data
            if (movie_rating == "None") {
              delete visualization_data[movie_name];
            } else {
              movie_data["movie_rating"] = parseFloat(movie_rating);
              visualization_data[movie_name] = movie_data;
            }
          });
          // see data format in console
          console.log(visualization_data);

          // plot 1 (avg age diff for each year + range )
          plotAvgAgeDiffVSYear(visualization_data);

          // plot 2 (age gap vs rating)
          plotAgeVsRating(visualization_data);
        });
      });

      // WHERE FIRST PLOT STARTS
      function plotAvgAgeDiffVSYear(visualization_data) {
        const yearAverageAgeGapData = {};

        for (const movieName in visualization_data) {
          const movieData = visualization_data[movieName];
          const movieYear = movieData.movie_year;

          //total age gap for movie
          const totalAgeGap = movieData.relationship_ages.reduce(
            (acc, ages) => {
              const [actor1Age, actor2Age] = ages;
              return acc + Math.abs(actor1Age - actor2Age);
            },
            0
          );

          //totalAgeGap and movie count for each year
          if (!(movieYear in yearAverageAgeGapData)) {
            yearAverageAgeGapData[movieYear] = {
              totalAgeGap: 0,
              movieCount: 0,
            };
          }
          yearAverageAgeGapData[movieYear].totalAgeGap += totalAgeGap;
          yearAverageAgeGapData[movieYear].movieCount++;
        }

        //avg age gap for each year
        const yearAverageAgeGapArray = [];
        for (const year in yearAverageAgeGapData) {
          const { totalAgeGap, movieCount } = yearAverageAgeGapData[year];
          const averageAgeGap = totalAgeGap / movieCount;
          yearAverageAgeGapArray.push({ year: +year, averageAgeGap });
        }

        //SVG container
        const margin = { top: 20, right: 30, bottom: 30, left: 30 };
        const width = 2000 - margin.left - margin.right; // Increased width because of all years
        const height = 400 - margin.top - margin.bottom;

        const svg = d3
          .select("#plot1")
          .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
          .append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);

        //BAR GRAPH
        const x = d3
          .scaleBand()
          .domain(yearAverageAgeGapArray.map((d) => d.year))
          .range([0, width])
          .padding(0.1); // Adjusted padding as well

        const y = d3
          .scaleLinear()
          .domain([0, d3.max(yearAverageAgeGapArray, (d) => d.averageAgeGap)])
          .nice()
          .range([height, 0]);

        svg
          .append("g")
          .selectAll(".bar")
          .data(yearAverageAgeGapArray)
          .enter()
          .append("rect")
          .attr("class", "bar")
          .attr("x", (d) => x(d.year))
          .attr("y", (d) => y(d.averageAgeGap))
          .attr("width", x.bandwidth())
          .attr("height", (d) => height - y(d.averageAgeGap))
          .attr("fill", "darkblue"); //Changed color color

        svg
          .append("g")
          .attr("class", "x-axis")
          .attr("transform", `translate(0,${height})`)
          .call(d3.axisBottom(x));

        svg.append("g").attr("class", "y-axis").call(d3.axisLeft(y));
      }

      // WHERE SECOND PLOT FUNCTION STARTS
      function plotAgeVsRating(visualization_data) {
        const div = d3.select("#plot2");

        // turn data into an array (missing title) so it can work with d3
        // each element formatted as such: {ageGap=n, ratings=[]}
        // ageGap ^ is unique
        let data_array = [];

        const plotSize = { width: 500, height: 500 };
        const plotMargins = { top: 10, right: 10, bottom: 50, left: 50 };
        const axisPadding = 5;

        // format data
        for (const [title, data] of Object.entries(visualization_data)) {
          const rating = data["movie_rating"];

          for (const ageRange of data["relationship_ages"]) {
            const ageGap = Math.abs(ageRange[0] - ageRange[1]);

            if (data_array[ageGap]) data_array[ageGap].ratings.push(rating);
            else data_array[ageGap] = { ageGap: ageGap, ratings: [rating] };
          }
        }

        // remove all empty elements
        data_array = data_array.filter((d) => d != null);

        // add rating averages
        data_array.forEach((d) => (d.avgRating = d3.mean(d.ratings)));

        const ageExtent = d3.extent(data_array, (d) => d.ageGap);
        const ratingExtent = d3.extent(data_array, (d) => d.avgRating);

        const yScale = d3
          .scaleLinear()
          .domain(ratingExtent) // [0, ratingExtent[1]] to make y minimum = 0
          .range([plotSize.height, 0]);

        const xScale = d3
          .scaleLinear()
          .domain(ageExtent)
          .range([0, plotSize.width]);

        const svg = div
          .append("svg")
          .attr("width", plotSize.width + plotMargins.left + plotMargins.right)
          .attr(
            "height",
            plotSize.height + plotMargins.top + plotMargins.bottom
          );
        // group for all plot elements (circles, lines, etc)

        const plotGroup = svg
          .append("g")
          .attr(
            "transform",
            `translate(${plotMargins.left}, ${plotMargins.top})`
          )
          .style("fill", "black");

        // y axis
        svg
          .append("g")
          .attr(
            "transform",
            `translate(${plotMargins.left - axisPadding}, ${plotMargins.top})`
          )
          .call(d3.axisLeft(yScale));

        // y axis grid
        svg
          .append("g")
          .attr(
            "transform",
            `translate(${plotMargins.left + plotSize.width},${plotMargins.top})`
          )
          .attr("opacity", 0.2)
          .call(
            d3
              .axisLeft(yScale)
              .tickSize(plotSize.width + axisPadding)
              .tickFormat(() => {})
          );

        // x axis
        svg
          .append("g")
          .attr(
            "transform",
            `translate(${plotMargins.left}, ${
              plotMargins.top + plotSize.height + axisPadding
            })`
          )
          .call(d3.axisBottom(xScale));
        // x axis grid
        svg
          .append("g")
          .attr(
            "transform",
            `translate(${plotMargins.left},${plotMargins.top})`
          )
          .attr("opacity", 0.2)
          .call(
            d3
              .axisBottom(xScale)
              .tickSize(plotSize.height + axisPadding)
              .tickFormat(() => {})
          );

        // draw line
        const lineGen = d3
          .line()
          .x((d) => xScale(d.ageGap))
          .y((d) => yScale(d.avgRating));

        plotGroup
          .append("path")
          .datum(data_array)
          .attr("d", lineGen)
          .attr("stroke", "black")
          .attr("stroke-width", 1);
        //.attr('fill', 'none') // comment this to add fill

        // draw circles
        plotGroup
          .selectAll("circle")
          .data(data_array)
          .join("circle")
          .attr("r", 3)
          .attr("cx", (d) => xScale(d.ageGap))
          .attr("cy", (d) => yScale(d.avgRating));

        // x-axis label
        svg
          .append("text")
          .attr("text-anchor", "middle")
          .attr(
            "transform",
            `translate(${plotSize.width / 2 + plotMargins.left - axisPadding}, 
            ${plotSize.height + plotMargins.bottom})`
          )
          .text("Age Gap");

        // y-axis label
        svg
          .append("text")
          .attr("text-anchor", "middle")
          .attr("transform", "rotate(-90)")
          .attr(
            "transform",
            `translate(${axisPadding * 2}, ${plotSize.height / 2}) rotate(-90)`
          )
          .text("Movie Rating");
      }
    </script>
  </body>
</html>
